\documentclass[10pt]{report}


\usepackage[pdftex]{graphicx}
\usepackage{url} 
\usepackage[dvips, bookmarks, colorlinks=false, pdfborder={0 0 0}, pdftitle={<pdf title here>}, pdfauthor={<author's name here>}, pdfsubject={<subject here>}, pdfkeywords={<keywords here>}]{hyperref} 
\usepackage[final]{pdfpages}
\usepackage{multirow}
\usepackage[table]{xcolor} 
\usepackage{subfigure}
\usepackage{booktabs}


\newtheorem{example}{Example}[section]
\newtheorem{defn}{Def}
\newcommand{\ESIM}{\textsc{E}\small{\texttt{SIM}}~}
\newcommand\T{\rule{0pt}{3.1ex}}		% To add space b/w words and top \hline
\renewcommand{\figurename}{Fig.}

\newcommand\counter[1]{\arabic{#1} \stepcounter{#1}}
\newcounter{syscall}
\title{XOS \\ eXperimental Operating System \\
Version 1.0}
\author{Dr. K. Muralikrishnan  \\ \texttt{kmurali@nitc.ac.in} \\ {NIT Calicut} }


\begin{document}

\maketitle
\pagebreak

%......................Table of Contents............................%
\thispagestyle{plain}

\tableofcontents
\pagebreak

\chapter{Introduction}
\label{chp:osintro}

XOS (Experimental Operating System) is an experimental operating system  which is designed to be run on the  XSM  (Experimental String Machine) architecture which is a simulated machine hardware. XOS is intended as an instructional tool to help students learn essential concepts of an operating system. 
\vspace{0.1in} \\
XOS is programmed using a custom language, SPL (System Programmer's Language) which compiles to XSM compatible code. (Refer SPL Specification) Application programs for XSM are written in APL (Application Programmer's Language). (Refer APL Specification ) 
\vspace{0.1in} \\
The programs, data and operating system code is stored on a disk which has an XFS (Experimental File System) in it. (Refer XFS Specification)\\

The various functionalities of XOS include
\begin{itemize}
\item \textbf{Process Management}, includes scheduling and dispatching processes to the CPU. XOS is capable of \textit{multiprogramming} (the ability to run more than one process.  simultaneously). Refer Chapter~\ref{chp:process}
\item \textbf{Memory Management}, involves allocating memory for processes, demand paging (loading memory pages from the disk as and when required). Refer Chapter~\ref{chp:memory management}
\item \textbf{System Calls}. XOS provides various system calls for the user processes to execute certain kernel level operations. Refer Chapter~\ref{chp:system_calls}
\end{itemize} 


\chapter{Memory Organization}
\label{chp:memoryorg}
\index{Memory Organization}

The operating system organizes memory as given below:
\begin{figure}[htp!] \small
	\centering
	\begin{tabular}{|c|c|c|c|}
	\toprule
		\textbf{Page No.} & \textbf{Contents} & \textbf{Word Address} & \textbf{$\#$ of words}\\
	\toprule
		0   & \hyperref[lbl:romcode]{ROM Code} 		& 0 -- 511 & 512\\ \hline 
		1   & \hyperref[lbl:oscode]{OS Startup code} 	& 512 -- 1023 & 512 \\ \hline 
		\multirow{5}{*}{2} 
			& \hyperref[lbl:pgtbl]{Per-Process Page Tables}   & 1024 -- 1279 & 256\\ \cline{2-4} 
			& \hyperref[lbl:memlst]{Memory Free List}  & 1280 -- 1343 & 64  \\ \cline{2-4}
			& \hyperref[lbl:gft]{System-wide Open File Table}  & 1344 -- 1471 & 128 \\ \cline{2-4} 
			& Unallocated & 1472 -- 1535 & 64\\ \hline 
		3 & \multirow{2}{*}
			{\hyperref[lbl:disklst]{Ready List of PCBs}} & \multirow{2}{*}{1536 -- 2559} & \multirow{2}{*}
			{1024}\\ \cline{1-1} 
		4 & 				&  & \\ \hline 
		5 & \hyperref[lbl:fat]{File Allocation Table} & 2560 -- 3071 &  512 \\ 
		\hline
		6 & \hyperref[lbl:fat]{Disk Free List} & 3072 -- 3583 &  512 \\ 
		\hline
		7 & \hyperref[lbl:fat]{Page Fault Handler} & 3584 -- 4095 &  512 \\ 
		\hline
		8 & \hyperref[lbl:fat]{Timer Interrupt Routine} & 4096 -- 4607 &  512 \\ 
		\hline
		9 & \hyperref[lbl:fat]{Interrupt 1 Routine} & 4608 -- 5119 &  512 \\ 
		\hline
		10 & \hyperref[lbl:fat]{Interrupt 2 Routine} & 5120 -- 5631 &  512 \\ 
		\hline
		11 & \hyperref[lbl:fat]{Interrupt 3 Routine} & 5632 -- 6143 &  512 \\ 
		\hline
		12 & \hyperref[lbl:fat]{Interrupt 4 Routine} & 6144 -- 6655 &  512 \\ 
		\hline
		13 & \hyperref[lbl:fat]{Interrupt 5 Routine} & 6656 -- 7167 &  512 \\ 
		\hline
		14 & \hyperref[lbl:fat]{Interrupt 6 Routine} & 7168 -- 7679 &  512 \\ 
		\hline
		15 & \hyperref[lbl:fat]{Interrupt 7 Routine} & 7680 -- 8191 &  512 \\ 
		\hline
		16 &  &  &  512 $\times$ 48\\ 
		\vdots & INIT and User Programs & 8192 -- 32767 &    = 24576 \\
		63 &  &  & \\  
		\hline
	\end{tabular}
	\caption{Outline of the main memory}
	\index{Memory!Organization}
\end{figure}
\begin{itemize}
	\item \textbf{ROM Code}, Read Only Memory is hard coded assembly code which loads the operating system startup code from the disk. (Refer Section 3.3 of XSM Specification) 
	\item \textbf{OS Startup code}, loads the INIT process to memory, data structures like FAT and Disk Free List, and Interrupt Routines from the disk. Refer Section~\ref{sec:os startup code}
	\item \textbf{Per-Process Page Tables}, used for address translation of logical addresses to physical address. Refer Section~\ref{sec:pagetable}
	\item \textbf{Memory Free List}, is a list of free memory locations in the memory. Refer Section~\ref{sec:mem free list}
	\item \textbf{System-wide Open File Table}, contains a details of files which are opened by the processes. Refer Section~\ref{sec:file table}
	\item \textbf{Ready List of PCBs}, is a list of Process Control Blocks, which indicates the ready and terminated processes. Refer Section~\ref{sec:pcb}
	\item \textbf{File Allocation Table}, contains details about files stored on the disk, Refer Section~\ref{sec:fat}
	\item \textbf{Disk Free List}, contains details about used and used blocks in the disk, Refer Section~\ref{sec:disk free list}
	\item \textbf{Exception Handler}, contains the kernel code to be executed during a page fault exception, Refer Section~\ref{sec:ex_handler}
	\item \textbf{Timer Interrupt Routine}, contains the kernel code to be executed during a timer interrupt. Refer Section~\ref{sec:timer}
	
	\item \textbf{Interrupt Routines}, contains kernel code to be executed during interrupts (1 to 7). Refer Section~\ref{sec:interrupt}
	\item \textbf{INIT and User Programs}, is the memory space allocated for user programs in execution. Refer Section~\ref{sec:init and userprogs}
\end{itemize}




\chapter{Process Management}
\label{chp:process}
\index{Process}

\section{Introduction}
Any program in its execution is called a \textbf{process}. Processes will be loaded into memory before they start their execution. Each process occupies \textbf{at most 4 pages} of the memory. The processor generates logical addresses with respect to a process during execution, which is translated to the physical address. This translation is done by the machine using page tables, Refer Section 3.2 of XSM Specification\\ 

The XSM architecture supports demand paging and so the machine does not fix the number of processes that can be run on it. However XOS has limited the number of process running simultaneously to 32, due to limitations in number of PCBs in the Ready List (Refer Section~\ref{sec:pcb}) and the number of Per-Process Page Tables (Refer Section~\ref{sec:pagetable})\\




\section{Process Structure}
\label{sec:procstruct}
\index{Process!Structure}
A process in the memory has the following structure.
\begin{itemize}
	\item \textbf{Code Area :} \index{Process!Code Area} These are pages of the memory that contain the executable code loaded from the disk. 
	\item \textbf{Stack :} This is the user stack used for program execution. The variables and data used during execution of program is stored in the stack. It grows in the direction of increasing word address.
\end{itemize}

Figure~\ref{fig:process structure} shows the process structure. \\

\begin{figure}[htp!] 
	\centering
	\begin{tabular}{|c|} 
		\textbf{Contents}    \\ \cline{1-1}
		\multirow{2}{*}{Code} \\
				       \\ \cline{1-1}
		\noalign{\smash{\llap{\lower2pt\hbox{\tt BP$\longrightarrow$}}}}
		 \\
	  \\
		\noalign{\smash{\llap{\raise2pt\hbox{\tt $\bigg \downarrow$ }}}}
		Stack  \\ \cline{1-1}
		\noalign{\smash{\llap{\lower2pt\hbox{\tt SP$\longrightarrow$}}}}
	\end{tabular}
	\caption{Logical Address Space of a Process}
	\label{fig:process structure}
\end{figure}




\section{Process Control Block (PCB)}
\label{sec:pcb}
\index{Process Data Structures!Process Control Block}
It contains data pertaining to the current state of the process. The size of the PCB is \textbf{32 words}. Refer figure~\ref{fig:pcb}.\\


	\begin{figure}[htp!]
		\centering
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
			\hline
			0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 -- 14 & 15 - 30 &  31 \\
			\hline
			PID & STATE & BP & SP & IP & PTBR & PTLR & R0 -- R7 & Per-Process & Free\\ & & & & & & & & Open File Table &   \\
			\hline
		\end{tabular}
		\caption{Structure of Process Control Block}
		\label{fig:pcb}
	\end{figure}

 \subsection{Process Identifier (PID)}
 \label{sec:pid}
 The process identifier is a number from 0 to 31, which identifies the processes in memory. The PID of the current process can be calculated from the \texttt{PTBR} register.
 
	 \subsection{Process State} 
	 \label{sec:processstate}
	 The process state corresponding to a process, indicated by \texttt{STATE} in the PCB stores the state of that process in the memory. A process can be in one of the following states. 
	\begin{itemize}
		\item \textbf{0} for \textit{terminated}, i.e. process has completed execution
		\item \textbf{1} for \textit{ready}, i.e. process is waiting for the CPU to start execution.
		\item \textbf{2} for \textit{running}, i.e. the process is currently running in the CPU
	\end{itemize}
	
	  \subsection{Registers}
	  \label{sec:registers} 
\begin{itemize}
	\item \textbf{IP}: The word address of the currently executing instruction is stored in the \texttt{IP} (Instruction Pointer) register. The value of this register cannot be changed explicitly by any instruction. 
	
	\index{Registers!IP}
	\item \textbf{BP}:   The base address of the user stack is stored in the \texttt{BP} (Base Pointer) register. \index{Registers!BP}
	\item \textbf{SP}: The address of the stack top is stored in the \texttt{SP} (Stack Pointer) register. \index{Registers!SP}
	\item \textbf{PTBR}: The physical address of the Per-Process Page Table of the process is stored in the \texttt{PTBR} (Page Table Base Register).\index{Registers!PTBR}
	\item  \textbf{PTLR}: The length of the Per-Process Page Table (No. of entries) is stored in the \texttt{PTLR} (Page Table Length Register). It is fixed as \textbf{4} for every process in XOS. \index{Registers!PTLR}
	
\end{itemize}
Each process has its own set of values for the various registers. Words  2	 -- 6 in the PCB stores the values of the registers associated with the process .
	
	
\subsection{Per-Process Open File Table} 
\label{sec:processfile table}
	 
	  The Per-Process Open File Table contains details of files opened by the corresponding process. Every entry in this table occupies 2 words. A maximum of 8 files can be opened by a process at a time, i.e. up to 8 entries in the PCB. It is stored in the PCB from words 15 to 30. Its structure is given below


		\begin{figure}[htp!]
		\centering
		\begin{tabular}{|c|c|}
			\textit{1 word} & \textit{1 word} \\
			\hline
			Pointer to system-wide & \texttt{LSEEK} position\\ open file table entry &  \\
			\hline
		\end{tabular}
		\caption{Structure of Per-Process Open File Table}
		\label{fig:processfile table}
	\end{figure}
\begin{itemize}
\item
The OS maintains a system wide open file table which contains details of all the files that are opened by processes (Refer Section~\ref{sec:file table}). The entry in the Per-Process File Table points to the System-wide Open File Table entry corresponding to the file. 
\item It also stores the \texttt{LSEEK} position for the file, which indicates the word in the file to which the process currently points to for read/write operations. 
\end{itemize}




\section{Ready List}
\index{Process!Ready List}
\label{sec:readylist}

The list of PCBs stored in the memory is used as a Ready List by the operating system to schedule processes to CPU. The \texttt{STATE} in the PCB indicates whether a process is ready for execution or not.  A new process in memory is scheduled for execution by circularly traversing through the list of PCBs stored in memory and selecting the first Ready process after the PCB of the currently running process in the list.\\

A maximum of 32 PCBs can be stored in the memory, and hence the maximum number of processes that can be run simultaneously is limited to 32. The PCB list is stored in pages 3 and 4 in the memory (words 1536 -- 2559)

\section{The Per-Process Page Tables}
\label{sec:pagetable}
\index{Process!Page Table}
Every process in XOS has a Per-Process Page Table. A total of 32 PCBs and 32 Page Tables in total are available, which limits the number of processes that can be run to 32. \\

		\begin{figure}[htp!]
		\centering
		\begin{tabular}{|c|c|}
		\hline
		  	 	& 			\\ 
		 	Physical Page Number & Auxiliary Information  \\
			 	& 			\\  \hline
		\end{tabular}
		\caption{Structure of a valid Page Table Entry}
		\label{fig:pagetable}
	\end{figure}


The Per-Process Page Table stores the physical page number corresponding to each logical page associated with the process. The logical page number can vary from 0 to 3 for each process.  Therefore, each process has 4 entries in the page table. Per-Process Page Tables are stored in Page 2, words 1024 -- 1279 in the memory (256 words = 32 processes $\times$ 4 pages )\\

When a process is loaded only the disk addresses of the program are stored, and by demand paging (Refer Section~\ref{sec:paging}) pages are loaded/allocated for the process.	 Once all pages are loaded, each entry contains the page number where the data specified by the logical address resides in the memory and auxiliary information which includes \textit{valid/invalid bit}, \textit{reference bit} etc.

		\begin{figure}[htp!]
		\centering
		\begin{tabular}{|c|c|c}
			\textit{Physical Page Number} & \textit{Auxiliary Information (Valid Bit)} \\
			\cline{0-1}
			36 & 1  & \footnotesize \textit{ {Valid page in memory}}\\
			\cline{0-1}
			311 & 0 & \footnotesize \textit{ {Disk Block No. is stored }}\\
			\cline{0-1}
			54 &  1 & \footnotesize \textit{ {Valid page in memory}}\\
			\cline{0-1}
			490 & 0 & \footnotesize \textit{ {Page in swap area in disk}}\\
			\cline{0-1}
		\end{tabular}
		\caption{Structure of Per-Process Page Table}
		\label{fig:processfile table}
	\end{figure}
	
\section{Multiprogramming}
\label{sec:multiprogramming}
	
The operating system allows multiple processes to be run on the machine and manages the system resources among these processes. This process of simultaneous execution of multiple processes is known as \emph{multiprogramming}.  \\

To support multiprogramming in the system, the kernel makes use of the \emph{scheduler} which is present in the Timer Interrupt Service Routine in Page 8 of the memory.

\section{INIT and User Processes}
\label{sec:init and userprogs}

The \texttt{INIT} process is the first user program that is loaded by the OS after start up. The \texttt{INIT} and other user processes uses the memory pages 16 - 63 for execution (Code Area and Stack). 





\chapter{Memory Management}
\label{chp:memory management}
\section{Introduction}

XSM uses a paging mechanism for address translation (Refer Section 3.2 of XSM Specification). XOS supports virtual memory, i.e. it supports execution of processes that are not completely in memory. It follows \textit{pure demand paging} strategy for memory management. Pages are allocated as and when required during execution. 

\section{Paging}
\label{sec:paging}
\index{Page }

Paging is the memory management scheme that permits the physical address space of a process to be non-contiguous. Each process has its own page table (Refer Section~\ref{sec:pagetable}), which is used for paging. 

 The Per-Process Page Table contains information relating to the actual location in the memory. Each valid entry of a page table contains the page number in the memory where the data specified by the logical address resides. The address of Page Table of the currently executing process is stored in \texttt{PTBR} and length of the page table is set to 4 in \texttt{PTLR} of the machine. The structure of an entry in the page table is given below.

		\begin{figure}[htp!]
		\centering
		\begin{tabular}{|c|c|}
		\hline
		  	 	& 			\\ 
		 	Physical Page Number & Auxiliary Information  \\
			 	& 			\\  \hline
		\end{tabular}
		\caption{Structure of Page Table Entry}
		\label{fig:pagetable entry}
	\end{figure}

\begin{itemize}
	\item \textit{Physical Page Number}: The logical page numbers generated by the CPU for a process can be in the range 0 to 3. The actual location of these logical pages are given by the physical page number. Address translation is done by the machine (Refer Section 3.2 of XSM Specification)
	
	\item \textit{Auxiliary Information}: The 2nd word for the entry contains auxiliary information, which are a sequence of flags. The structure of auxiliary information is given below
			\begin{figure}[htp!]
		\centering
		\begin{tabular}{|c|c|c|c|c|}
		0 & 1 & 2 & \ldots & 15 \\
		\hline
		\texttt{VI} & \texttt{R} & \textbackslash 0 & \ldots &  \textbackslash 0 \\
		\hline
		\end{tabular}
		\end{figure}
	
		\begin{itemize}
			\item \textit{Valid/Invalid Bit} (\texttt{VI}): is a value 1 or 0 for valid and invalid respectively. It is valid if and only if the entry is a physical memory location. It is invalid if either the entry points to location on the disk or if its not in the logical address space of the process.
			\item \textit{Reference Bit} (\texttt{R}): This bit is set to 1 by the machine every time a page is accessed. This bit is used for page replacement (Refer Section~\ref{sec:page fault}) by the OS. 
		\end{itemize}

\end{itemize}
	
\section{Memory Free List}
\label{sec:mem free list}
\index{Memory!Free list}

The free list of the memory consists of 64 entries. Each entry is of size one word. Thus, the total size of the free list is thus 64 words. It is present in words 1280 to 1343 in memory. (words 256 to 319 of Page ) of the memory. Refer Chapter~\ref{chp:memoryorg}. Each entry of the free list contains a value of either 0 or 1 indicating whether the corresponding page in the memory is free or not respectively.

 
\section{Virtual Memory}
\label{sec:virtualmem}

XOS allows virtual memory management, i.e. running processes without having all the pages in memory. It makes use of a backing store or \textbf{\textit{swap}} in the disk to replace pages from the memory and allocate the emptied memory to another process. This increases the total number of processes that can be run simultaneously on the OS.\\

XOS starts executing a process with no pages of that process in memory. Pages are loaded into the memory from the disk only when it is required by the CPU. This strategy is known as pure demand paging. The page table is loaded with the disk address of the data blocks corresponding to the process and all entries are set as invalid and not referenced initially (`00' as auxiliary information).\\

Page Fault Exceptions occur when a required page is not currently loaded into the memory. In this case the Exception Handler Routine is responsible for loading the required page to the memory from the disk. If no free memory is available a page replacement technique is used to find a victim page. The page replacement technique used in XOS is a \textit{second chance algorithm}(Refer Silberschatz, Galvin, Gagne: Operating System Concepts) which uses the \textit{reference bits} in the auxiliary information. The victim page is swapped out to to the disk (swap area) to accommodate the required page.



 \chapter{Files}
\label{chp:files}

The operating system requires accessing the file system (XFS) while loading programs, and reading data from the files. The operating system maintains a memory copy of the file system data structures like FAT(File Allocation Table) and Disk Free List (Refer Chapter~\ref{chp:memoryorg}). It is loaded from the disk to the memory during operating system boot. \\
 Apart from the file system data structures XOS maintains details about files opened by all processes in the System-wide Open File Table. XOS uses a \texttt{scratchpad} to access files in the memory which will be explained further in this chapter.
 

\section{File Allocation Table (FAT)}
\index{File Allocation Table}
\label{sec:fat}
\emph{File allocation table} (FAT) is a table that has an entry for each file present in the disk. FAT is stored in page number 5 in the memory. \\

	\index{File Allocation Table!Location in disk}


The structure of a FAT entry is shown below 

\begin{figure}[htp!] \small
	\centering
	\begin{tabular}{|c|c|c|c|}
		\hline
		0 & 1 & 2 & 3 -- 7 \\
		\hline
		File Name & File Size & Block no: of basic block & \dots{} Unused \dots \\
		\hline
	\end{tabular}
	\caption{Structure of a FAT entry}
	\label{fig:fat_entry}
\end{figure}



\section{Disk Free List}
\index{Disk Free List}
\label{sec:disk free list}
The Disk Free List is a data structure used for keeping track of unused blocks in the disk. The memory copy of Disk Free List is stored in the \textit{page number} 6. It is stored in \textit{block number} 11 in the disk. 


\section{System Wide Open File Table}
\label{sec:file table}
	
This data structure maintains details about all open files in the system. It is located from words 1344 to 1471 of the memory (in Page 2). System Wide Open File Table consists of a maximum of 64 entries. 
Therefore, there can be at most 64 open files in the system at any time. Each entry of the System Wide Open File Table occupies 2 words. It has the following structure as shown in figure~\ref{fig:file table}.

	 \begin{figure}[h!]
		 \centering
			\begin{tabular}{|c|c|}
				1 word & 1 word	\\		
				\hline
				FAT Index Entry & File Open Count\\
				\hline
			\end{tabular}
		 \caption{Structure of an entry}
		 \label{fig:file table}
	 \end{figure}

	 \begin{itemize}
		 \item \textbf{FAT index entry :} \index{File Allocation Table!Memory copy} It stores the index of the corresponding file in the FAT.

		 \item \textbf{File Open Count :} File Open Count is the number of open instances of the file. When this becomes zero, the entry for the file can be removed from the System Wide Open File Table.
	 \end{itemize}

The Per-Process Open File Table in the PCB of each process stores information about files opened by the corresponding process. Each entry in the Per-Process Open File Table has the index to the file's entry  in the  System-wide Open File Table.

\section{Scratchpad}
\label{sec:scratchpad}
\index{Scratchpad}
There is a specific page of the memory which is reserved to store temporary data. This page is known as the \textit{Scratchpad}. The scratchpad is required since any block of the disk cannot be accessed directly  by a process. It has to be present in the memory for access. Hence, any disk block that has to be read or written into is first brought into the scratchpad. It is then read or modified and written back into the disk. \\

The \textit{page number} 1 of the memory (Refer Chapter \ref{chp:memoryorg}) is used as the scratchpad. Once the OS has booted up there is no need for the OS startup code. So this page can be reused as the scratchpad.


\chapter{System Calls}
\label{chp:system_calls}
\index{System Calls}

\section{Introduction}
System calls are interfaces through which a process communicates with the OS. Each system call has a unique name associated with it (Halt, Open, Read, Fork etc). Each of these names maps to a unique system call number. Each system call in turn causes an interrupt to occur. Note that multiple system calls can be mapped to the same interrupt.

All the arguments to the system call are pushed into the user stack of the process which invokes the system call. The system call number is pushed as the last argument. (Refer APL Specification)


\section{Machine System Calls}

\subsection{Halt}
\label{sec:haltsyscall}
\index{File System Calls!Halt}

APL Syntax : \texttt{Halt()} \\
System Call No. : \counter{syscall} \\

The Halt system call is used to halt the machine. Halt system call calls the interrupt \texttt{INT 5}.


\section{File System Calls}
\label{sec:fssyscall}
\textit{File system calls} are used by a process when it has to create, delete or manipulate \textit{Data files} that reside on the disk(file system). There are seven file system calls. An interrupt is associated with each system call. All the necessary arguments for a system call are available in the user stack with the system call number as the last argument.\\

\subsection{Create}
\label{sec:create()}

APL Syntax : \texttt{int Create(fileName)} \\
System Call No. : \counter{syscall} \\

This system call is used to create a new file in the file system whose name is specified in the argument. The return value of the \texttt{Create()} system call is 0 if it is a success, and an error code otherwise. It calls Interrupt 1 Routine.\\

\subsection{Delete}
\label{sec:delete()}

APL Syntax : \texttt{int Delete(fileDescriptor)} \\
System Call No. : \counter{syscall} \\

This system call is used to delete the file from the file system whose name is specified in the argument. The return value of the \texttt{Delete()} system call is 0 if it is a success, and an error code otherwise. It calls Interrupt 1 Routine. \\

\subsection{Open}
\label{sec:open()}

APL Syntax : \texttt{int Open(fileName)} \\
System Call No. : \counter{syscall} \\

This system call is used to open an existing file whose name is specified in the argument.  It calls Interrupt 2 Routine. The return value of the \texttt{Create()} system call is an integer value called \texttt{FileDescriptor}, which is the index of the corresponding file's entry in the Per-Process Open File Table.\\


\subsection{Close}
\label{sec:close()}

APL Syntax : \texttt{int Close(fileName)} \\
System Call No. : \counter{syscall} \\

This system call is used to close an open file. The file can only be closed by the process which opened it. \texttt{FileDescriptor} is an integer value returned by the corresponding \texttt{Open()} system call. The return value of the \texttt{Close()} system call is 0 if it is a success, and an error code otherwise. It calls Interrupt 2 Routine. \\


\subsection{Seek}
\label{sec:seek()}

APL Syntax : \texttt{int Seek(FileDescriptor, lseek)}  \\
System Call No. : \counter{syscall} \\

This system call is used to change the current value of the seek position in the global file table entry of a file. The return value of the \texttt{Seek()} system call is 0 if it is a success, and an error code otherwise. It calls Interrupt 3 Routine. \\


\subsection{Read}
\label{sec:read()}

APL Syntax : \texttt{int Read(fileDescriptor, mem\_loc, numWords)}  \\
System Call No. : \counter{syscall} \\

This system call is used to read data from an open file (identified by \texttt{fileDescriptor}) to the memory (identified by \texttt{memory\_loc}). The return value of the \texttt{Read()} system call is the number of words successfully read from the file or an error code otherwise. It calls Interrupt 3 Routine. \\

\subsection{Write}
\label{sec:write()}

APL Syntax : \texttt{int Write(fileDescriptor, mem\_loc, numWords)}  \\
System Call No. : \counter{syscall} \\

This system call is used to write data into an open file (identified by \texttt{fileDescriptor}) from the memory (identified by \texttt{mem\_loc}). The return value of the \texttt{Write()} system call is 
the number of words successfully written to the file or an error code otherwise. It calls Interrupt 4 Routine. \\

	
\section{Process System Calls}
\label{sec:procsyscall}
\index{Process System Calls}
\textit{Process system calls} are used by a process when it has to duplicate itself, execute a new process in its place or when it has to terminate itself. There are three process system calls. An interrupt is associated with each system call. All the necessary arguments for a system call are available in the user stack with the system call number as the last argument.\\


\subsection{Fork}
\label{sec:fork()}

APL Syntax :  \texttt{int Fork()} \\
System Call No. : \counter{syscall} \\

This system call is used to replicate the process which invoked this system call in the memory. The new process which is created is known as the \emph{child} and the process which invoked this system call is known as its \emph{parent}. The return value for \texttt{Fork()} system call to the parent process is the PID (\textit{process identifier}) of the child process.  It calls Interrupt 5 Routine. \\


\subsection{Exec}
\label{sec:exec()}

APL Syntax :  \texttt{int Exec(filename)} \\
System Call No. : \counter{syscall} \\

This system call is used to load the program, whose name is specified in the argument, in the memory space of the current process and start its execution .  The return value for \texttt{Exec()} system call 1 in case of failure and none in case of failure. It calls Interrupt 6 Routine.  \\

\subsection{Exit}

\label{sec:exit()}

APL Syntax :  \texttt{Exit()} \\
System Call No. : \counter{syscall} \\

This system call is used to terminate the execution of the process which invoked it and removes it from the memory . It loads the next available process. It calls Interrupt 7 Routine.  \\

\chapter{System Routines}

\label{chp:sys routines}

The Operating System apart from its various data structures and interfaces it provides to the user processes, has certain routines to execute while start up and during interrupts. These routines are included as the Operating System Routines.

\section{OS Startup Code}
\label{sec:os startup code}
The OS Startup Code resides in the page 1 in the memory. When the machine boots up the ROM Code (Refer XSM Specification) loads the OS Startup Code from the disk . The OS Startup code initializes all data structures required for the OS, loads the FAT and Disk Free List from file system into the memory and starts execution of the \texttt{INIT} process.

\section{Exception Handler}
\label{sec:ex_handler}
When the machine encounters an exception it sets EFR (Exception Flag Register) with details corresponding to the exception and calls the exception handler routine (Page No. 7 in memory).
(Refer 6.1 of XSM Specification)

		\begin{figure}[htp!]
		\centering
		\begin{tabular}{|c|c|c|c|}
		\hline
		\texttt{Value of IP} & \texttt{BadVAddr} & \texttt{Cause} &  \textbackslash 0 \\
		\hline
		\end{tabular}
		\caption{Structure of EFR }
		\end{figure}
		
XOS handles all  exceptions other than \textit{Page Fault} by killing the process which caused the exception. 

\subsubsection{Page Fault Exceptions}
\label{sec:page fault}
The \texttt{Cause} field of \texttt{EFR} for Page Fault Exceptions is\textbf{ 0}. Once a page fault occurs, the Exception Handler Routine loads the required page to the memory from the disk, if it does not exist. The corresponding entry for the logical page which caused the exception to occur (indicated by \texttt{BadVAddr} field in \texttt{EFR} ) will be invalid in the page table of the process. 

\section{Timer Interrupt Routine}
\label{sec:timer}

The Timer Interrupt Routine is responsible for context switch, i.e. storing the state (values of the registers) of the currently executing process to the PCB, and setting the registers with values from the PCB of the next ready process in the Ready List of PCBs. A scheduler is responsible for selecting a ready process from this list. The Scheduler code is also contained in the Timer Interrupt Routine.

\section{Interrupt Routines}
\label{sec:interrupt}
The Interrupts from 1 to 7  are invoked by the user processes through system calls. Each interrupt routine has code corresponding to one or more system calls. Refer Chapter on System Calls. 

\end{document}
